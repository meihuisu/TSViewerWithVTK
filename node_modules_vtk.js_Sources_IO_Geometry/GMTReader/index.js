
//
// GMT file reader (Generic Mapping Tools file format)
//
// based on 
// ...node_modules/vtk.js/Sources/IO/Misc/OBJReader/index.js
// awk '$1~"VRTX" {print "v",$3,$5,-$4} $1~"TRGL" {print "f",$2,$3,$4}' test.ts > test.obj 
//

import macro from 'vtk.js/Sources/macro';
import DataAccessHelper from 'vtk.js/Sources/IO/Core/DataAccessHelper';
import vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';

// ----------------------------------------------------------------------------

const data = {};

// ----------------------------------------------------------------------------

function begin(splitMode) {
  data.splitOn = splitMode;
  data.pieces = [];
  data.v = [];
  data.vset = []; // vertex
  data.size = 0;
}

// ----------------------------------------------------------------------------

function parseLine(line) {
  if (line[0] === '#') { // comment lines
    return;
  }
  const tokens = line.split(/[ \t]+/);
  if (tokens[0] === "NaN") { // this is a disjoint marker
    const n=data.size-1;
    const nn=data.pieces[n];
    data.pieces.push(nn);
    data.size++;
    if(data.v.length != 0) {
      data.vset.push(data.v);
      data.v = [];
    }
  } else if (tokens[0] === "" && tokens[1] != undefined) { // this is a vertex/point
    data.v.push(Number(tokens[1]));
    data.v.push(Number(tokens[3]));
    data.v.push(-1 * Number(tokens[2]));
  } else if (tokens[0] === '>') { // start of a trace name
    let x=tokens[1];
    x = x.replace(/\"/g, '');
    data.pieces.push(x);
    data.size++;
    if(data.v.length != 0) {
      data.vset.push(data.v);
      data.v = [];
    }
  } else { // last line
    if(data.v.length != 0) {
      data.vset.push(data.v);
      data.v = [];
    }
    if(data.vset.length != data.pieces.length) {
      window.console.log("CHECK this.. needs to match up");
    }
  }
}

// ----------------------------------------------------------------------------

function end(model) {
  model.numberOfOutputs = data.size;
  if(data.size > 0) {
    for (let idx = 0; idx < data.size; idx++) {
      let name=data.pieces[idx];
      let polydata = vtkPolyData.newInstance({ name: data.pieces[idx] });
      let pts = data.vset[idx];

//https://discourse.vtk.org/t/how-can-i-split-a-polyline-into-its-linear-segments/2434
//https://discourse.vtk.org/t/how-to-manually-create-a-polydata-with-multi-line-segments-in-vtk-js/3636

      const cellArray = [];
      let cnt=pts.length;
      cellArray.push(cnt);
      for(let i=0; i<cnt; i++) {
        cellArray.push(i);
      }
      polydata.getLines().setData(Uint16Array.from(cellArray));
      polydata.getPoints().setData(Float32Array.from(pts), 3);

      // register in output
      model.output[idx] = polydata;
    }
  } 
}

// ----------------------------------------------------------------------------
// vtkGMTReader methods
// ----------------------------------------------------------------------------

function vtkGMTReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkGMTReader');

  // Create default dataAccessHelper if not available
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get('http');
  }

  // Internal method to fetch Array
  function fetchData(url, option = {}) {
    return model.dataAccessHelper.fetchText(publicAPI, url, option);
  }

  // Set DataSet url
  publicAPI.setUrl = (url, option = {}) => {
    if (url.indexOf('.utm') === -1 && !option.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.utm`;
    } else {
      model.url = url;

      // Remove the file in the URL
      const path = url.split('/');
      path.pop();
      model.baseURL = path.join('/');
    }

    // Fetch metadata
    return publicAPI.loadData(option);
  };

  // Fetch the actual data arrays
  publicAPI.loadData = (option = {}) =>
    fetchData(model.url, option).then(publicAPI.parseAsText);

  publicAPI.parseAsText = (content) => {
    if (!content) {
      return true;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    }
    model.parseData = content;
    model.numberOfOutputs = 0;
    begin(model.splitMode);
    content.split('\n').forEach(parseLine);
    end(model);
    return true;
  };

  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsText(model.parseData);
  };

  // return Busy state
  publicAPI.isBusy = () => !!model.requestCount;

  publicAPI.getNumberOfOutputPorts = () => model.numberOfOutputs;

  publicAPI.getOutputName = (inIdx) => {
    publicAPI.parseAsText(model.parseData);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  numberOfOutputs: 1,
  requestCount: 0,
  splitMode: null,
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ['url', 'baseURL']);
  macro.setGet(publicAPI, model, ['dataAccessHelper', 'splitMode']);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, 'busy');

  // Object methods
  vtkGMTReader(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkGMTReader');

// ----------------------------------------------------------------------------

export default { newInstance, extend };
