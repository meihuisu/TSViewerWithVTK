//
// EQ file reader (similar to GMTReader but creates multiple  1 cell vtkPolyVertex polyData)
//
// based on GMTReader/index.js 
//

import macro from 'vtk.js/Sources/macro';
import DataAccessHelper from 'vtk.js/Sources/IO/Core/DataAccessHelper';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';

// ----------------------------------------------------------------------------

const data = {};

// ----------------------------------------------------------------------------

function begin(splitMode) {
  data.splitOn = splitMode;
  data.v = [];  // temporary collecting location
  data.vset = []; // sets of vertex group
  data.vsetcnt = []; // count of points in vertex group
  data.group = []; // meta of each vertex group
  data.groupcnt = 0; // number of vertex groups
}

// ----------------------------------------------------------------------------

function parseLine(line) {
  if (line[0] === '#') { // comment lines
    return;
  }
  const tokens = line.split(/[ \t]+/);
  if (tokens[0] === "" && tokens[1] != undefined) { // this is a vertex/point
    data.v.push(Number(tokens[1]));
    data.v.push(Number(tokens[3]));
    data.v.push(-1 * Number(tokens[2]));
  } else if (tokens[0] === '>') { // start of a separate group, group meta
    let ss=line.indexOf('{');
    let y=line.substring(ss,);
    data.group.push(y);
    data.groupcnt++;
    if(data.v.length > 0) {
      data.vsetcnt.push(data.v.length/3);
      data.vset.push(data.v);
      data.v = [];
    }
  } else { // last line ??? not sure
    data.vsetcnt.push(data.v.length/3);
    data.vset.push(data.v);
    data.v = [];
    if(data.vset.length != data.groupcnt) {
      window.console.log("CHECK this.. needs to match up");
    }
  }
}

// ----------------------------------------------------------------------------

function end(model) {
  model.numberOfOutputs = data.groupcnt;
  if(data.groupcnt > 0) {
    for (let idx = 0; idx < data.groupcnt; idx++) {
      const gmeta=data.group[idx];

      const polydata = vtkPolyData.newInstance({ meta:gmeta });
      // Points
      const pts = data.vset[idx];
      polydata.getPoints().setData(Float32Array.from(pts), 3);
      // Cells
      const ptscnt = data.vsetcnt[idx];
      const verts = new Uint32Array(ptscnt + 1);
      polydata.getVerts().setData(verts, 1);
      verts[0] = ptscnt;
      for (let i = 0; i < ptscnt; i++) {
        verts[i + 1] = i;
      }

      // register in output
      model.output[idx] = polydata;
    }
  } 
}

// ----------------------------------------------------------------------------
// vtkEQReader methods
// ----------------------------------------------------------------------------

function vtkEQReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkEQReader');

  // Create default dataAccessHelper if not available
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get('http');
  }

  // Internal method to fetch Array
  function fetchData(url, option = {}) {
    return model.dataAccessHelper.fetchText(publicAPI, url, option);
  }

  function numberOfPoints(idx) {
    if(idx > data.vset.length) {
      return 0;
    }
    let num=data.vsetcnt[idx];
    return num;
  }

  // Set DataSet url
  publicAPI.setUrl = (url, option = {}) => {
    if (url.indexOf('.utm') === -1 && !option.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.utm`;
    } else {
      model.url = url;

      // Remove the file in the URL
      const path = url.split('/');
      path.pop();
      model.baseURL = path.join('/');
    }

    // Fetch metadata
    return publicAPI.loadData(option);
  };

  // Fetch the actual data arrays
  publicAPI.loadData = (option = {}) =>
    fetchData(model.url, option).then(publicAPI.parseAsText);

  publicAPI.parseAsText = (content) => {
    if (!content) {
      return true;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    }
    model.parseData = content;
    model.numberOfOutputs = 0;
    begin(model.splitMode);
    content.split('\n').forEach(parseLine);
    end(model);
    return true;
  };

  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsText(model.parseData);
  };

  // return Busy state
  publicAPI.isBusy = () => !!model.requestCount;

  publicAPI.getNumberOfOutputPorts = () => model.numberOfOutputs;
  publicAPI.getNumberOfPoints = (inIdx) => {
      return numberOfPoints(inIdx);
  }

  publicAPI.getOutputName = (inIdx) => {
    publicAPI.parseAsText(model.parseData);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  numberOfOutputs: 1,
  requestCount: 0,
  splitMode: null,
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ['url', 'baseURL']);
  macro.setGet(publicAPI, model, ['dataAccessHelper', 'splitMode']);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, 'busy');

  // Object methods
  vtkEQReader(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkEQReader');

// ----------------------------------------------------------------------------

export default { newInstance, extend };
